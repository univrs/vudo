-- DOL 2.0 Type Aliases and Struct Syntax Specification
-- Part of VUDO Genesis Year 1 - Type System Design
-- Generated by Hive Mind Queen Coordinator

module dol.types.aliases @ 2.0.0

import dol.types.primitives.{Int32, Int64, UInt64, Float64, String, Bool}
import dol.types.composites.{Optional, Vec, Slice}

exegesis {
  Type aliases create named references to existing types,
  enabling more expressive and domain-specific code.

  DOL supports three forms of type definition:
  1. Simple aliases - new name for existing type
  2. Struct types - record types with named fields
  3. Enum types - sum types with variants

  All type definitions support generic parameters and constraints.
}


-- ═══════════════════════════════════════════════════════════════════
-- SIMPLE TYPE ALIASES
-- ═══════════════════════════════════════════════════════════════════

exegesis {
  Simple aliases create a new name for an existing type.
  The new type is interchangeable with the original.

  MLIR Lowering:
    type TaskId is UInt64 → type alias, lowers to !i64 directly

  Syntax:
    type NewName is ExistingType

  Examples:
    type TaskId is UInt64
    type Timestamp is Int64
    type Probability is Float64
}

-- Common aliases used throughout DOL systems
type TaskId is UInt64
type ProcessId is UInt64
type ThreadId is UInt64
type Timestamp is Int64
type Duration is Int64
type Priority is Int32
type Probability is Float64
type Percentage is Float64
type Radians is Float64
type Degrees is Float64


-- ═══════════════════════════════════════════════════════════════════
-- NEWTYPE PATTERN
-- ═══════════════════════════════════════════════════════════════════

exegesis {
  Newtypes create distinct types that are NOT interchangeable
  with the underlying type. This provides type safety.

  MLIR Lowering:
    newtype TaskId is UInt64 → !dol.newtype<"TaskId", !i64>

  Syntax:
    newtype NewName is ExistingType

  Example:
    newtype Meters is Float64
    newtype Feet is Float64
    -- Meters and Feet are incompatible, preventing unit errors
}

-- Newtype declaration
gene Newtype<Name: String, T> {
  type: T

  exegesis {
    Newtype wraps a value to create a distinct type.
    Explicit conversion is required to unwrap.
  }

  function wrap(value: T) -> Newtype<Name, T> {
    return Newtype { value: value }
  }

  function unwrap(self) -> T {
    return self.value
  }
}

-- Example newtypes for units
newtype Meters is Float64
newtype Feet is Float64
newtype Kilograms is Float64
newtype Pounds is Float64
newtype Seconds is Float64
newtype Milliseconds is Int64


-- ═══════════════════════════════════════════════════════════════════
-- STRUCT TYPES (Records)
-- ═══════════════════════════════════════════════════════════════════

exegesis {
  Struct types define record types with named fields.
  Structs are product types - they contain all their fields.

  MLIR Lowering:
    type Point is { x: Float64, y: Float64 }
    → !llvm.struct<(f64, f64)> with field metadata

  Syntax:
    type Name is {
      field1: Type1,
      field2: Type2,
      ...
    }

  Features:
  - Named field access
  - Structural equality
  - Pattern matching support
  - Optional default values
}

-- 2D Point
type Point2D is {
  x: Float64,
  y: Float64
}

-- 3D Point
type Point3D is {
  x: Float64,
  y: Float64,
  z: Float64
}

-- Rectangle
type Rectangle is {
  top_left: Point2D,
  width: Float64,
  height: Float64
}

-- Color (RGBA)
type Color is {
  r: UInt8,
  g: UInt8,
  b: UInt8,
  a: UInt8
}

-- Time range
type TimeRange is {
  start: Timestamp,
  end: Timestamp
}

-- Generic key-value pair
type KeyValue<K, V> is {
  key: K,
  value: V
}


-- ═══════════════════════════════════════════════════════════════════
-- STRUCT WITH DEFAULTS
-- ═══════════════════════════════════════════════════════════════════

exegesis {
  Struct fields can have default values.
  Fields with defaults can be omitted during construction.

  Syntax:
    type Config is {
      timeout: Duration = 30_000,  -- default: 30 seconds
      retries: Int32 = 3,
      verbose: Bool = false
    }

  Usage:
    config: Config = { timeout: 60_000 }  -- other fields use defaults
}

-- Configuration with defaults
type HttpConfig is {
  host: String,                          -- required
  port: UInt16 = 8080,                   -- default
  timeout_ms: Duration = 30_000,         -- default
  max_retries: Int32 = 3,                -- default
  keep_alive: Bool = true                -- default
}

-- Logger configuration
type LogConfig is {
  level: LogLevel = LogLevel.Info,
  output: LogOutput = LogOutput.Stdout,
  format: LogFormat = LogFormat.Text,
  include_timestamp: Bool = true
}

type LogLevel is enum {
  Trace,
  Debug,
  Info,
  Warn,
  Error
}

type LogOutput is enum {
  Stdout,
  Stderr,
  File(path: String)
}

type LogFormat is enum {
  Text,
  Json
}


-- ═══════════════════════════════════════════════════════════════════
-- ENUM TYPES (Sum Types / Tagged Unions)
-- ═══════════════════════════════════════════════════════════════════

exegesis {
  Enum types define sum types with variants.
  A value is exactly one of the variants.

  MLIR Lowering:
    type Status is enum { Running, Stopped }
    → !dol.enum<"Status", [Running, Stopped]>
    Represented as: { tag: i8, payload: max_variant_size }

  Syntax:
    type Name is enum {
      Variant1,
      Variant2(field: Type),
      Variant3 { named: Type, fields: Type }
    }

  Features:
  - Unit variants (no data)
  - Tuple variants (positional data)
  - Struct variants (named fields)
  - Pattern matching required for exhaustive handling
}

-- Simple status enum
type Status is enum {
  Pending,
  Running,
  Complete,
  Failed
}

-- Status with data
type TaskStatus is enum {
  Pending,
  Running { progress: Percentage, started_at: Timestamp },
  Complete { finished_at: Timestamp, result: String },
  Failed { error: String, attempts: Int32 }
}

-- Result of a computation (generic)
type ComputeResult<T, E> is enum {
  Success(value: T),
  Failure(error: E),
  Cancelled,
  TimedOut { after: Duration }
}

-- Network event
type NetworkEvent is enum {
  Connected { peer_id: String, address: String },
  Disconnected { peer_id: String, reason: String },
  MessageReceived { from: String, payload: Slice<UInt8> },
  Error { code: Int32, message: String }
}

-- AST node (self-referential enum)
type Expr is enum {
  Literal { value: LiteralValue },
  Variable { name: String },
  Binary { op: BinOp, left: Box<Expr>, right: Box<Expr> },
  Unary { op: UnaryOp, operand: Box<Expr> },
  Call { callee: Box<Expr>, args: Vec<Expr> },
  Lambda { params: Vec<String>, body: Box<Expr> },
  If { condition: Box<Expr>, then_branch: Box<Expr>, else_branch: Optional<Box<Expr>> }
}

type LiteralValue is enum {
  Int(value: Int64),
  Float(value: Float64),
  String(value: String),
  Bool(value: Bool),
  Null
}

type BinOp is enum {
  Add, Sub, Mul, Div, Mod,
  Eq, Ne, Lt, Le, Gt, Ge,
  And, Or,
  Pipe, Compose
}

type UnaryOp is enum {
  Neg, Not
}


-- ═══════════════════════════════════════════════════════════════════
-- GENERIC TYPE ALIASES
-- ═══════════════════════════════════════════════════════════════════

exegesis {
  Type aliases can be generic, parameterized over other types.

  Syntax:
    type Pair<A, B> is Tuple<A, B>
    type List<T> is Vec<T>

  With constraints:
    type SortedList<T> where T: Ord is Vec<T>
}

-- Generic aliases
type Pair<A, B> is Tuple<A, B>
type Triple<A, B, C> is Tuple<A, B, C>

-- Aliases for common patterns
type List<T> is Vec<T>
type Dict<K, V> where K: Hashable + Eq is Map<K, V>
type Set<T> where T: Hashable + Eq is Map<T, ()>

-- Callback types
type Callback<T> is Function<T, Void>
type Predicate<T> is Function<T, Bool>
type Mapper<A, B> is Function<A, B>
type Reducer<A, B> is Function<(B, A), B>
type Comparator<T> is Function<(T, T), Ordering>

-- Async types
type Future<T, E> is enum {
  Pending,
  Ready(value: Result<T, E>)
}

type Promise<T, E> is {
  future: Future<T, E>,
  resolver: Function<Result<T, E>, Void>
}

-- Stream type
type Stream<T> is trait {
  requires next: Function<Self, Optional<T>>
}


-- ═══════════════════════════════════════════════════════════════════
-- TYPE CONSTRUCTORS (Box, Rc, Arc)
-- ═══════════════════════════════════════════════════════════════════

exegesis {
  Special type constructors for memory management.
  These enable recursive types and shared ownership.
}

-- Heap-allocated box (unique ownership)
gene Box<T> {
  type: Pointer<T>

  exegesis {
    Box<T> is a heap-allocated value with unique ownership.
    Used for recursive types and large values.

    MLIR Lowering: !llvm.ptr with ownership semantics
  }

  function new(value: T) -> Box<T> {
    ptr: Pointer<T> = alloc(sizeof(T))
    unsafe { *ptr = value }
    return Box { ptr: ptr }
  }

  function deref(self) -> T {
    return unsafe { *self.ptr }
  }
}

-- Reference-counted pointer (shared ownership, single-threaded)
gene Rc<T> {
  type: {
    ptr: Pointer<RcInner<T>>
  }

  exegesis {
    Rc<T> provides shared ownership via reference counting.
    Not thread-safe; use Arc for multi-threaded scenarios.

    MLIR Lowering: !dol.rc<{T.mlir}>
  }

  function new(value: T) -> Rc<T> {
    inner: Pointer<RcInner<T>> = alloc(sizeof(RcInner<T>))
    unsafe {
      (*inner).value = value
      (*inner).ref_count = 1
    }
    return Rc { ptr: inner }
  }

  function clone(self) -> Rc<T> {
    unsafe { (*self.ptr).ref_count = (*self.ptr).ref_count + 1 }
    return Rc { ptr: self.ptr }
  }

  function deref(self) -> T {
    return unsafe { (*self.ptr).value }
  }
}

type RcInner<T> is {
  value: T,
  ref_count: UInt64
}

-- Atomic reference-counted pointer (thread-safe)
gene Arc<T> {
  type: {
    ptr: Pointer<ArcInner<T>>
  }

  exegesis {
    Arc<T> provides thread-safe shared ownership.
    Reference count updates are atomic.

    MLIR Lowering: !dol.arc<{T.mlir}>
  }

  function new(value: T) -> Arc<T> {
    inner: Pointer<ArcInner<T>> = alloc(sizeof(ArcInner<T>))
    unsafe {
      (*inner).value = value
      atomic_store(&(*inner).ref_count, 1)
    }
    return Arc { ptr: inner }
  }

  function clone(self) -> Arc<T> {
    unsafe { atomic_fetch_add(&(*self.ptr).ref_count, 1) }
    return Arc { ptr: self.ptr }
  }

  function deref(self) -> T {
    return unsafe { (*self.ptr).value }
  }
}

type ArcInner<T> is {
  value: T,
  ref_count: AtomicUInt64
}


-- ═══════════════════════════════════════════════════════════════════
-- ORDERING AND COMPARISON
-- ═══════════════════════════════════════════════════════════════════

type Ordering is enum {
  Less,
  Equal,
  Greater
}

trait Ord {
  requires compare: Function<(Self, Self), Ordering>

  provides lt: Function<(Self, Self), Bool> {
    return |a, b| { a.compare(b) == Ordering.Less }
  }

  provides le: Function<(Self, Self), Bool> {
    return |a, b| { a.compare(b) != Ordering.Greater }
  }

  provides gt: Function<(Self, Self), Bool> {
    return |a, b| { a.compare(b) == Ordering.Greater }
  }

  provides ge: Function<(Self, Self), Bool> {
    return |a, b| { a.compare(b) != Ordering.Less }
  }
}

trait Eq {
  requires eq: Function<(Self, Self), Bool>

  provides ne: Function<(Self, Self), Bool> {
    return |a, b| { not a.eq(b) }
  }
}

trait Hashable {
  requires hash: Function<Self, UInt64>
}


-- ═══════════════════════════════════════════════════════════════════
-- MLIR TYPE MAPPINGS SUMMARY
-- ═══════════════════════════════════════════════════════════════════

exegesis {
  MLIR Lowering Summary for Type Aliases:

  Simple Aliases:
    type TaskId is UInt64         → i64 (transparent)
    type Timestamp is Int64       → i64 (transparent)

  Newtypes:
    newtype Meters is Float64     → !dol.newtype<"Meters", f64>

  Structs:
    type Point2D is { x: Float64, y: Float64 }
    → !llvm.struct<(f64, f64)>
    With metadata: dol.struct.fields = ["x", "y"]

  Enums:
    type Status is enum { Pending, Running, Complete }
    → !dol.enum<"Status">
    Struct: { tag: i8, padding: ..., payload: max_variant_size }

  Generic Types:
    type List<T> is Vec<T>
    → Substitutes T at instantiation

  Smart Pointers:
    Box<T>  → !llvm.ptr
    Rc<T>   → !dol.rc<{T}>
    Arc<T>  → !dol.arc<{T}>
}


-- ═══════════════════════════════════════════════════════════════════
-- EXPORTS
-- ═══════════════════════════════════════════════════════════════════

export {
  -- Simple aliases
  TaskId, ProcessId, ThreadId,
  Timestamp, Duration, Priority,
  Probability, Percentage,
  Radians, Degrees,

  -- Newtypes
  Newtype,
  Meters, Feet, Kilograms, Pounds,
  Seconds, Milliseconds,

  -- Struct types
  Point2D, Point3D, Rectangle, Color,
  TimeRange, KeyValue,
  HttpConfig, LogConfig, LogLevel, LogOutput, LogFormat,

  -- Enum types
  Status, TaskStatus, ComputeResult,
  NetworkEvent, Expr, LiteralValue, BinOp, UnaryOp,

  -- Generic aliases
  Pair, Triple, List, Dict, Set,
  Callback, Predicate, Mapper, Reducer, Comparator,
  Future, Promise, Stream,

  -- Smart pointers
  Box, Rc, Arc,

  -- Ordering and traits
  Ordering, Ord, Eq, Hashable
}
