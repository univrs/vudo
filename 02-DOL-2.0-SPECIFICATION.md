# DOL 2.0: Turing Complete Language Specification

> *Design Ontology Language — The language that writes itself*

## Overview

DOL 2.0 extends the original specification language into a fully Turing-complete programming language while maintaining its core identity: **ontology-first development**. Systems describe what they *are* before what they *do*.

This specification is designed to align with MLIR (Multi-Level IR) for seamless lowering to WASM and native targets.

---

## Design Principles

1. **Plain English Aesthetic** — Code reads like documentation
2. **Explicit Types** — All values carry type information (MLIR alignment)
3. **Braces for Scope** — Clear visual boundaries with `{ }`
4. **Ontology Primitives** — Gene, Trait, Constraint, System, Evolves remain core
5. **Self-Referential** — DOL can describe and compile itself

---

## Type System

### Primitive Types

```dol
-- Integer types (signed)
type Int8      -- 8-bit signed integer    → !i8
type Int16     -- 16-bit signed integer   → !i16  
type Int32     -- 32-bit signed integer   → !i32
type Int64     -- 64-bit signed integer   → !i64

-- Integer types (unsigned)
type UInt8     -- 8-bit unsigned          → !ui8
type UInt16    -- 16-bit unsigned         → !ui16
type UInt32    -- 32-bit unsigned         → !ui32
type UInt64    -- 64-bit unsigned         → !ui64

-- Floating point
type Float32   -- 32-bit IEEE 754         → !f32
type Float64   -- 64-bit IEEE 754         → !f64

-- Boolean
type Bool      -- true or false           → !i1

-- Void (unit type)
type Void      -- no value                → none

-- String (UTF-8, heap allocated)
type String    -- variable length         → !dol.string
```

### Composite Types

```dol
-- Fixed-size array
type Array<T, N: UInt64>     -- Array<Int32, 10>    → !dol.array<!i32, 10>

-- Dynamic slice (fat pointer: ptr + length)
type Slice<T>                -- Slice<Int32>        → !dol.slice<!i32>

-- Raw pointer (unsafe)
type Pointer<T>              -- Pointer<Int32>      → !dol.ptr<!i32>

-- Optional value
type Optional<T>             -- Optional<Int32>     → !dol.optional<!i32>

-- Result type
type Result<T, E>            -- Result<Int32, IoError> → !dol.result<!i32, !dol.IoError>

-- Tuple (heterogeneous)
type Tuple<...T>             -- Tuple<Int32, String, Bool>

-- Function type
type Function<Args, Ret>     -- Function<(Int32, Int32), Int32>
```

### Ontological Types (DOL-Specific)

```dol
-- Gene: Atomic unit of truth with constraints
type Gene<T>                 -- Gene<ProcessId>     → !dol.gene<!dol.ProcessId>

-- Trait: Composable behavior specification
type Trait                   -- → !dol.trait

-- Constraint: Invariant that must hold
type Constraint              -- → !dol.constraint

-- System: Top-level composition
type System                  -- → !dol.system

-- Evolves: Version lineage record
type Evolves<T>              -- → !dol.evolves<T>
```

### Type Aliases

```dol
-- Create named type aliases
type TaskId is UInt64
type Timestamp is Int64
type Priority is Int32

-- Struct-like records
type Point is {
  x: Float64,
  y: Float64
}

-- Enum types
type Status is enum {
  Pending,
  Running,
  Complete,
  Failed(message: String)
}
```

---

## Control Flow

### Conditionals

```dol
-- Basic if/else
function classify(value: Int32) -> String {
  if value > 100 {
    return "high"
  } else if value > 50 {
    return "medium"
  } else {
    return "low"
  }
}

-- If as expression
function abs(x: Int32) -> Int32 {
  return if x < 0 { -x } else { x }
}

-- Guard clauses
function divide(a: Int32, b: Int32) -> Optional<Int32> {
  if b == 0 {
    return None
  }
  return Some(a / b)
}
```

### Pattern Matching

```dol
-- Match on enums
function describe_status(status: Status) -> String {
  match status {
    Pending {
      return "Waiting to start"
    }
    Running {
      return "Currently executing"
    }
    Complete {
      return "Finished successfully"
    }
    Failed(msg) {
      return "Error: " + msg
    }
  }
}

-- Match with guards
function categorize(n: Int32) -> String {
  match n {
    0 {
      return "zero"
    }
    x where x > 0 {
      return "positive"
    }
    _ {
      return "negative"
    }
  }
}

-- Match on Result
function process(result: Result<Int32, String>) -> Int32 {
  match result {
    Ok(value) where value > 0 {
      return value * 2
    }
    Ok(value) {
      return 0
    }
    Err(msg) {
      log_error(msg)
      return -1
    }
  }
}
```

### Loops

```dol
-- For-in loop (iterators)
function sum(items: Slice<Int32>) -> Int32 {
  total: Int32 = 0
  for item in items {
    total = total + item
  }
  return total
}

-- While loop
function find_index(items: Slice<Int32>, target: Int32) -> Optional<UInt64> {
  i: UInt64 = 0
  while i < items.length {
    if items[i] == target {
      return Some(i)
    }
    i = i + 1
  }
  return None
}

-- Infinite loop with break
function read_until_eof(reader: Reader) -> Slice<UInt8> {
  buffer: Vec<UInt8> = Vec.new()
  loop {
    byte: Optional<UInt8> = reader.read_byte()
    match byte {
      Some(b) {
        buffer.push(b)
      }
      None {
        break
      }
    }
  }
  return buffer.to_slice()
}

-- Continue keyword
function sum_positive(items: Slice<Int32>) -> Int32 {
  total: Int32 = 0
  for item in items {
    if item < 0 {
      continue
    }
    total = total + item
  }
  return total
}

-- Loop with label (for nested loops)
function find_in_matrix(matrix: Slice<Slice<Int32>>, target: Int32) -> Optional<Tuple<UInt64, UInt64>> {
  outer: for row_idx, row in matrix.enumerate() {
    for col_idx, value in row.enumerate() {
      if value == target {
        return Some((row_idx, col_idx))
      }
    }
  }
  return None
}
```

---

## Functional Composition

### Pipe Operator `|>`

Left-to-right data flow:

```dol
function process_data(raw: Slice<Int32>) -> Slice<Int32> {
  return raw
    |> filter(is_positive)
    |> map(double)
    |> sort(ascending)
    |> take(10)
}

-- Equivalent to:
-- take(10, sort(ascending, map(double, filter(is_positive, raw))))
```

### Compose Operator `>>`

Build function pipelines (right-to-left composition):

```dol
-- Create composed function
transform: Function<Int32, Int32> = double >> increment >> square

-- Usage
result: Int32 = transform(5)  -- square(increment(double(5))) = 121
```

### Apply Operator `@`

Explicit function application:

```dol
-- Standard call
result: Int32 = add(3, 4)

-- Apply operator (useful in meta-programming)
result: Int32 = add @ (3, 4)
```

### Bind Operator `:=`

Partial application:

```dol
-- Partial application with placeholder
add_five: Function<Int32, Int32> = add := (5, _)

-- Multiple placeholders
middle: Function<(Int32, Int32), Int32> = between := (_, 10, _)

-- Usage
result: Int32 = add_five(3)  -- 8
```

### Lambda Expressions

```dol
-- Full lambda
squared: Slice<Int32> = items |> map(|x: Int32| -> Int32 { x * x })

-- Type-inferred lambda (when context provides types)
doubled: Slice<Int32> = items |> map(|x| { x * 2 })

-- Multi-line lambda
processed: Slice<Int32> = items |> filter(|x: Int32| -> Bool {
  if x < 0 {
    return false
  }
  return x % 2 == 0
})
```

### Higher-Order Functions

```dol
function apply_twice(f: Function<Int32, Int32>, x: Int32) -> Int32 {
  return f(f(x))
}

function make_adder(n: Int32) -> Function<Int32, Int32> {
  return |x: Int32| -> Int32 { x + n }
}

-- Currying
function curry2<A, B, C>(f: Function<(A, B), C>) -> Function<A, Function<B, C>> {
  return |a: A| -> Function<B, C> {
    return |b: B| -> C { f(a, b) }
  }
}
```

---

## Meta-Programming

### Quote `'`

Capture code as AST:

```dol
-- Quote expression
ast: Ast = '{ x + y * 2 }

-- Quote statement
stmt_ast: Ast = '{
  if condition {
    do_something()
  }
}

-- Quote with holes (quasi-quoting)
template: Ast = '{ result = $expr + 1 }
```

### Eval `!`

Execute AST in context:

```dol
-- Evaluate with bindings
result: Int32 = !ast where { x = 3, y = 4 }  -- 11

-- Evaluate in current scope
x: Int32 = 10
y: Int32 = 5
result: Int32 = !ast  -- 20 (uses current scope)
```

### Macro `#`

Compile-time code generation:

```dol
-- Define macro
macro unless(condition: Ast, body: Ast) -> Ast {
  return '{ if not !condition { !body } }
}

-- Use macro
unless(list.is_empty()) {
  process(list)
}

-- Define with multiple arms
macro log(level: Ast, message: Ast) -> Ast {
  return '{
    if LOG_LEVEL >= !level {
      print("[" + stringify(!level) + "] " + !message)
    }
  }
}

-- Compile-time computation block
const FACTORIAL_10: Int64 = #{
  function fact(n: Int64) -> Int64 {
    if n <= 1 { return 1 }
    return n * fact(n - 1)
  }
  fact(10)
}
```

### Reflect `?`

Type introspection:

```dol
-- Get type information
function describe_type<T>() -> String {
  info: TypeInfo = ?T
  return "Type: " + info.name + ", size: " + info.size.to_string()
}

-- Get fields of struct
function print_fields<T>() -> Void {
  for field in ?T.fields {
    print(field.name + ": " + field.type_name)
  }
}

-- Check trait implementation
function is_schedulable<T>() -> Bool {
  return ?T.implements(Schedulable)
}

-- Runtime type check
function dynamic_dispatch(value: Any) -> String {
  match ?value {
    Int32 { return "integer" }
    String { return "string" }
    _ { return "unknown" }
  }
}
```

---

## Ontological Constructs

### Gene

Atomic units of truth with constraints:

```dol
gene ProcessId {
  type: UInt64
  
  constraint positive {
    this.value > 0
  }
  
  constraint max_value {
    this.value < 1_000_000
  }
  
  exegesis {
    ProcessId uniquely identifies a running process.
    Valid IDs are positive integers below one million.
  }
}

-- Usage
pid: Gene<ProcessId> = Gene.new(12345)
assert(pid.validate())  -- checks all constraints
```

### Trait

Composable behavior specifications:

```dol
trait Schedulable {
  requires priority: Function<Self, Int32>
  requires estimated_duration: Function<Self, Duration>
  
  provides compare: Function<(Self, Self), Ordering> {
    return |a: Self, b: Self| -> Ordering {
      a.priority().compare(b.priority())
    }
  }
  
  exegesis {
    Schedulable defines the interface for entities that can be
    scheduled by the orchestrator. Implementations must provide
    priority and duration estimates.
  }
}

trait Runnable {
  requires run: Function<Self, Result<Void, RunError>>
  requires cancel: Function<Self, Void>
  
  exegesis {
    Runnable entities can be executed and cancelled.
  }
}

-- Trait composition
trait Task extends Schedulable, Runnable {
  requires name: Function<Self, String>
}
```

### Constraint

Invariants that must hold:

```dol
constraint QueueNotOverflow {
  for queue in this.queues {
    queue.length <= queue.capacity
  }
  
  exegesis {
    No queue may exceed its defined capacity.
  }
}

constraint MonotonicTimestamps {
  for i in 1..this.events.length {
    this.events[i].timestamp >= this.events[i-1].timestamp
  }
  
  exegesis {
    Event timestamps must be monotonically increasing.
  }
}
```

### System

Top-level compositions:

```dol
system Scheduler {
  uses Schedulable
  uses Runnable
  
  state queue: PriorityQueue<Gene<Task>>
  state running: Optional<Gene<Task>>
  state completed: Vec<TaskId>
  
  constraint no_duplicate_tasks {
    for task in queue {
      task.id not in completed
    }
  }
  
  function schedule(task: Gene<Task>) -> Result<Void, ScheduleError> {
    if not task.satisfies(Schedulable) {
      return Err(ScheduleError.NotSchedulable)
    }
    if task.id in completed {
      return Err(ScheduleError.AlreadyCompleted)
    }
    queue.push(task)
    return Ok(())
  }
  
  function tick() -> Void {
    match running {
      Some(task) where task.is_complete() {
        completed.push(task.id)
        running = None
      }
      None where not queue.is_empty() {
        running = Some(queue.pop())
        running.unwrap().run()
      }
      _ {
        -- idle
      }
    }
  }
  
  exegesis {
    Scheduler manages task execution with priority-based ordering.
    Tasks must implement Schedulable and Runnable traits.
  }
}
```

### Evolves

Version lineage with migration:

```dol
evolves ProcessId > ProcessIdV1 @ 2.0.0 {
  -- New fields
  added namespace: Optional<String>
  
  -- Type changes
  changed id: UInt64 -> UInt128
  
  -- Removed fields
  removed legacy_flag
  
  migrate from ProcessIdV1 {
    return ProcessId {
      id: old.id as UInt128,
      namespace: None
    }
  }
  
  exegesis {
    ProcessId V2 expands to 128-bit IDs and adds optional namespacing.
    Migration from V1 is lossless; namespace defaults to None.
  }
}
```

---

## Module System

```dol
-- File: scheduler/core.dol
module scheduler.core @ 1.0.0

-- Standard library imports
import std.collections.{PriorityQueue, HashMap, Vec}
import std.time.{Duration, Timestamp}

-- Univrs runtime imports  
import univrs.runtime.{Gene, Trait, System}

-- Local imports
import scheduler.tasks.{Task, TaskId}
import scheduler.errors.{ScheduleError, RunError}

-- Re-exports
export {
  Scheduler,
  Schedulable,
  schedule,
  tick
}

-- Module-level documentation
exegesis {
  Core scheduler module providing task orchestration.
  
  Usage:
    import scheduler.core.{Scheduler, schedule}
    
    sched: Scheduler = Scheduler.new()
    schedule(sched, my_task)
}
```

---

## Error Handling

### Result Type

```dol
-- Explicit error handling
function read_file(path: String) -> Result<String, IoError> {
  handle: Optional<FileHandle> = open(path)
  
  match handle {
    None {
      return Err(IoError.NotFound(path))
    }
    Some(h) {
      content: String = h.read_all()
      h.close()
      return Ok(content)
    }
  }
}

-- Try operator for propagation
function parse_config(path: String) -> Result<Config, ConfigError> {
  content: String = try read_file(path)
    .map_err(|e| ConfigError.IoError(e))
  
  config: Config = try parse_json(content)
    .map_err(|e| ConfigError.ParseError(e))
  
  return Ok(config)
}
```

### Panic (Development Only)

```dol
function assert_positive(n: Int32) -> Int32 {
  if n <= 0 {
    panic("expected positive, got " + n.to_string())
  }
  return n
}

-- Debug assertions (removed in release builds)
debug_assert(index < array.length, "index out of bounds")
```

---

## MLIR Lowering Example

DOL code:

```dol
function add(a: Int32, b: Int32) -> Int32 {
  return a + b
}
```

Lowers to MLIR:

```mlir
func.func @add(%a: i32, %b: i32) -> i32 {
  %result = arith.addi %a, %b : i32
  return %result : i32
}
```

DOL Gene:

```dol
gene Counter {
  type: Int32
  
  constraint non_negative {
    this.value >= 0
  }
}
```

Lowers to MLIR:

```mlir
!dol.gene<"Counter", i32> = type opaque

func.func @Counter_validate(%self: !dol.gene<"Counter", i32>) -> i1 {
  %value = dol.gene.extract %self : i32
  %zero = arith.constant 0 : i32
  %valid = arith.cmpi sge, %value, %zero : i32
  return %valid : i1
}
```

---

## Self-Referential Bootstrap

DOL can describe its own syntax. Here is DOL's token definition in DOL:

```dol
-- File: dol/tokens.dol
module dol.tokens @ 0.1.0

gene Token {
  type: enum {
    -- Keywords
    Module, Import, Export, Function, Type, Gene, Trait,
    Constraint, System, Evolves, Exegesis, If, Else, Match,
    For, While, Loop, Break, Continue, Return, Try,
    
    -- Literals
    Integer(value: Int64),
    Float(value: Float64),
    String(value: String),
    Bool(value: Bool),
    
    -- Identifiers
    Identifier(name: String),
    
    -- Operators
    Plus, Minus, Star, Slash, Percent,
    Eq, Ne, Lt, Le, Gt, Ge,
    And, Or, Not,
    Pipe, Compose, Apply, Bind,
    Quote, Eval, Macro, Reflect,
    
    -- Delimiters
    LBrace, RBrace, LParen, RParen, LBracket, RBracket,
    Comma, Colon, Semicolon, Arrow, FatArrow,
    
    -- Special
    Eof, Error(message: String)
  }
  
  exegesis {
    Token represents a single lexical unit in DOL source code.
  }
}

gene Span {
  type: {
    start: UInt64,
    end: UInt64,
    line: UInt32,
    column: UInt32
  }
  
  exegesis {
    Span tracks source location for error reporting.
  }
}

gene SpannedToken {
  type: {
    token: Token,
    span: Span
  }
}
```

---

## Appendix: Reserved Keywords

```
-- Ontological
gene trait constraint system evolves exegesis

-- Module
module import export from as

-- Types
type is enum struct

-- Control
if else match for while loop break continue return try

-- Functions
function requires provides where

-- Operators (reserved symbols)
|> >> @ := ' ! # ?

-- Literals
true false None Some Ok Err

-- Future reserved
async await yield spawn
```

---

*"The system that describes itself, compiles itself."*
