-- DOL 2.0 Ontological Types Specification
-- Part of VUDO Genesis Year 1 - Type System Design
-- Generated by Hive Mind Queen Coordinator

module dol.types.ontology @ 2.0.0

import dol.types.primitives.{Int32, Int64, UInt64, String, Bool}
import dol.types.composites.{Optional, Result, Vec, Slice, Function}

exegesis {
  Ontological types are the heart of DOL - types that describe
  not just data structures, but the nature and essence of systems.

  These types enable ontology-first development: systems describe
  what they ARE before what they DO.

  The five pillars of DOL ontology:
  1. Gene     - Atomic unit of truth with constraints
  2. Trait    - Composable behavior specification
  3. Constraint - Invariant that must always hold
  4. System   - Top-level composition of behaviors
  5. Evolves  - Version lineage and migration

  All ontological types preserve DOL 1.0 compatibility while
  extending capabilities for Turing completeness.
}


-- ═══════════════════════════════════════════════════════════════════
-- GENE: Atomic Unit of Truth
-- ═══════════════════════════════════════════════════════════════════

gene Gene<T> {
  type: {
    value: T,
    constraints: Vec<Constraint>,
    exegesis: Optional<String>,
    metadata: GeneMetadata
  }

  exegesis {
    Gene<T> wraps a value of type T with semantic constraints and documentation.
    Genes are the atomic building blocks of DOL systems - they carry not just
    data but meaning, constraints, and self-documentation.

    A Gene is more than its wrapped value: it knows its invariants, can
    validate itself, and carries its documentation (exegesis) with it.

    MLIR Lowering:
      Gene<ProcessId> → !dol.gene<"ProcessId", !ui64>

      The MLIR representation includes:
      - The wrapped value type
      - A symbol reference to constraint validation functions
      - Metadata attributes for exegesis

    Memory Layout:
      - Value: sizeof(T)
      - Runtime validation: function pointer (8 bytes)
      - Total: sizeof(T) + 8 + metadata overhead

    Declaration Syntax:
      gene ProcessId {
        type: UInt64
        constraint positive { this.value > 0 }
        exegesis { Unique identifier for a running process. }
      }

    Usage Syntax:
      pid: Gene<ProcessId> = Gene.new(12345)
      if pid.validate() { ... }

    Example:
      gene Temperature {
        type: Float64

        constraint above_absolute_zero {
          this.value >= -273.15
        }

        constraint reasonable_range {
          this.value < 1_000_000.0
        }

        exegesis {
          Temperature in Celsius. Must be above absolute zero
          and within reasonable physical bounds.
        }
      }

      temp: Gene<Temperature> = Gene.new(20.0)
      assert(temp.validate())  -- checks all constraints
  }

  -- Create a new Gene with value
  function new(value: T) -> Gene<T> {
    g: Gene<T> = Gene {
      value: value,
      constraints: Vec.new(),
      exegesis: None,
      metadata: GeneMetadata.default()
    }
    return g
  }

  -- Extract the wrapped value (unchecked)
  function extract(self) -> T {
    return self.value
  }

  -- Extract with validation
  function extract_validated(self) -> Result<T, ValidationError> {
    if not self.validate() {
      return Err(ValidationError.ConstraintViolation(self.get_violations()))
    }
    return Ok(self.value)
  }

  -- Validate all constraints
  function validate(self) -> Bool {
    for constraint in self.constraints {
      if not constraint.check(self) {
        return false
      }
    }
    return true
  }

  -- Get constraint violations
  function get_violations(self) -> Vec<String> {
    violations: Vec<String> = Vec.new()
    for constraint in self.constraints {
      if not constraint.check(self) {
        violations.push(constraint.name + ": " + constraint.message)
      }
    }
    return violations
  }

  -- Get exegesis text
  function describe(self) -> String {
    match self.exegesis {
      Some(text) { return text }
      None { return "Gene<" + typename(T) + "> (no description)" }
    }
  }

  -- Map over the value (returns new Gene)
  function map<U>(self, f: Function<T, U>) -> Gene<U> {
    return Gene {
      value: f(self.value),
      constraints: Vec.new(),  -- constraints don't transfer
      exegesis: None,
      metadata: GeneMetadata.default()
    }
  }

  -- Check if satisfies a trait
  function satisfies<Tr: Trait>(self) -> Bool {
    return ?T.implements(Tr)
  }
}

-- Gene metadata for runtime reflection
type GeneMetadata is {
  created_at: Optional<Timestamp>,
  source_location: Optional<SourceSpan>,
  version: Optional<Version>
}

-- MLIR lowering for Gene
mlir Gene<T> {
  type: !dol.gene<{T.name}, {T.mlir}>

  attributes {
    dol.gene.constraints = array of symbol refs
    dol.gene.exegesis = string attr (optional)
  }

  operations {
    create: dol.gene.create
    extract: dol.gene.extract
    validate: dol.gene.validate  -- calls constraint functions
  }
}


-- ═══════════════════════════════════════════════════════════════════
-- TRAIT: Composable Behavior Specification
-- ═══════════════════════════════════════════════════════════════════

gene Trait {
  type: {
    name: String,
    requires: Vec<TraitRequirement>,
    provides: Vec<TraitProvision>,
    extends: Vec<Trait>,
    exegesis: Optional<String>
  }

  exegesis {
    Trait defines a composable set of behaviors that types can implement.
    Traits specify required behaviors (must be implemented) and provided
    behaviors (default implementations).

    Unlike interfaces in other languages, DOL traits:
    - Can have default implementations (provides)
    - Can extend multiple other traits
    - Carry their documentation (exegesis)
    - Support associated types and constants

    MLIR Lowering:
      trait Schedulable → !dol.trait<"Schedulable">

      Traits compile to:
      - Vtable structure for dynamic dispatch
      - Type constraints for static checking
      - Symbol tables for method resolution

    Declaration Syntax:
      trait Schedulable {
        requires priority: Function<Self, Int32>
        requires estimated_duration: Function<Self, Duration>

        provides compare: Function<(Self, Self), Ordering> {
          return |a, b| { a.priority().compare(b.priority()) }
        }

        exegesis {
          Schedulable entities can be ordered and scheduled.
        }
      }

    Implementation Syntax:
      implement Schedulable for Task {
        function priority(self) -> Int32 {
          return self.task_priority
        }

        function estimated_duration(self) -> Duration {
          return self.estimate
        }
      }

    Example:
      trait Runnable {
        requires run: Function<Self, Result<Void, RunError>>
        requires cancel: Function<Self, Void>

        provides is_cancellable: Function<Self, Bool> {
          return |_| { true }  -- default: all Runnables are cancellable
        }
      }

      trait Task extends Schedulable, Runnable {
        requires name: Function<Self, String>
      }
  }

  -- Check if a type implements this trait
  function is_implemented_by<T>(self) -> Bool {
    return ?T.implements(self)
  }

  -- Get all required methods
  function get_requirements(self) -> Slice<TraitRequirement> {
    return self.requires.as_slice()
  }

  -- Get all provided methods
  function get_provisions(self) -> Slice<TraitProvision> {
    return self.provides.as_slice()
  }

  -- Get all parent traits
  function get_parents(self) -> Slice<Trait> {
    return self.extends.as_slice()
  }

  -- Compose with another trait (creates new trait extending both)
  function compose(self, other: Trait) -> Trait {
    return Trait {
      name: self.name + "+" + other.name,
      requires: self.requires.concat(other.requires),
      provides: self.provides.concat(other.provides),
      extends: Vec.from([self, other]),
      exegesis: None
    }
  }
}

-- Trait requirement (must be implemented)
type TraitRequirement is {
  name: String,
  signature: FunctionSignature,
  exegesis: Optional<String>
}

-- Trait provision (has default implementation)
type TraitProvision is {
  name: String,
  signature: FunctionSignature,
  default_impl: Function<...>,
  exegesis: Optional<String>
}

-- MLIR lowering for Trait
mlir Trait {
  type: !dol.trait<{name}>

  struct vtable {
    -- One function pointer per required/provided method
    method_ptrs: !llvm.array<N x !llvm.ptr>
  }

  operations {
    implement: dol.trait.implement
    check: dol.trait.check
    dispatch: dol.trait.dispatch (dynamic dispatch via vtable)
  }
}


-- ═══════════════════════════════════════════════════════════════════
-- CONSTRAINT: Invariant That Must Hold
-- ═══════════════════════════════════════════════════════════════════

gene Constraint {
  type: {
    name: String,
    predicate: Function<Any, Bool>,
    message: String,
    exegesis: Optional<String>
  }

  exegesis {
    Constraint defines an invariant that must always hold.
    Constraints are checked at runtime and can be composed.

    Unlike assertions, constraints are:
    - Named and documented
    - Composable (AND, OR, NOT)
    - Attached to Genes and Systems
    - Part of the type's identity

    MLIR Lowering:
      constraint positive → !dol.constraint<"positive">

      Constraints compile to:
      - Predicate function
      - Metadata for error reporting

    Declaration Syntax (in Gene):
      constraint positive {
        this.value > 0
      }

    Declaration Syntax (standalone):
      constraint NonEmpty<T> for Slice<T> {
        this.length > 0

        exegesis { The slice must contain at least one element. }
      }

    Example:
      constraint ValidPercentage {
        this.value >= 0 and this.value <= 100

        exegesis {
          Percentage must be between 0 and 100 inclusive.
        }
      }

      gene Percentage {
        type: Float64
        uses ValidPercentage
      }
  }

  -- Check if constraint holds for a value
  function check<T>(self, value: T) -> Bool {
    return self.predicate(value)
  }

  -- Get error message for violation
  function violation_message(self) -> String {
    return "Constraint '" + self.name + "' violated: " + self.message
  }

  -- Compose constraints with AND
  function and(self, other: Constraint) -> Constraint {
    return Constraint {
      name: self.name + " AND " + other.name,
      predicate: |x| { self.check(x) and other.check(x) },
      message: self.message + "; " + other.message,
      exegesis: None
    }
  }

  -- Compose constraints with OR
  function or(self, other: Constraint) -> Constraint {
    return Constraint {
      name: self.name + " OR " + other.name,
      predicate: |x| { self.check(x) or other.check(x) },
      message: self.message + " or " + other.message,
      exegesis: None
    }
  }

  -- Negate constraint
  function not(self) -> Constraint {
    return Constraint {
      name: "NOT " + self.name,
      predicate: |x| { not self.check(x) },
      message: "must not satisfy: " + self.message,
      exegesis: None
    }
  }
}

-- MLIR lowering for Constraint
mlir Constraint {
  type: !dol.constraint<{name}>

  struct {
    predicate_fn: !llvm.ptr  -- function pointer
    name: !dol.string
    message: !dol.string
  }

  operations {
    check: dol.constraint.check
    compose_and: dol.constraint.and
    compose_or: dol.constraint.or
  }
}


-- ═══════════════════════════════════════════════════════════════════
-- SYSTEM: Top-Level Composition
-- ═══════════════════════════════════════════════════════════════════

gene System {
  type: {
    name: String,
    state: SystemState,
    traits: Vec<Trait>,
    constraints: Vec<Constraint>,
    functions: Vec<SystemFunction>,
    exegesis: Optional<String>
  }

  exegesis {
    System is the top-level organizational unit in DOL.
    Systems compose traits, define state, and implement behaviors.

    A System is a living entity that:
    - Has state that changes over time
    - Uses traits to define capabilities
    - Maintains constraints (invariants)
    - Exposes functions for interaction

    MLIR Lowering:
      system Scheduler → !dol.system<"Scheduler">

      Systems compile to:
      - State struct
      - Function table
      - Constraint check functions
      - Trait vtables for implemented traits

    Declaration Syntax:
      system Scheduler {
        uses Schedulable
        uses Runnable

        state queue: PriorityQueue<Gene<Task>>
        state running: Optional<Gene<Task>>

        constraint no_duplicates {
          -- queue has no duplicate task IDs
        }

        function schedule(task: Gene<Task>) -> Result<Void, ScheduleError> {
          -- implementation
        }

        function tick() -> Void {
          -- implementation
        }

        exegesis {
          Scheduler manages task execution with priority ordering.
        }
      }

    Example:
      system Counter {
        state count: Int32 = 0

        constraint non_negative {
          this.count >= 0
        }

        function increment() -> Void {
          self.count = self.count + 1
        }

        function decrement() -> Result<Void, CounterError> {
          if self.count == 0 {
            return Err(CounterError.AlreadyZero)
          }
          self.count = self.count - 1
          return Ok(())
        }

        function get() -> Int32 {
          return self.count
        }

        exegesis {
          A simple counter that can never go negative.
        }
      }
  }

  -- Create new system instance
  function new() -> Self {
    -- Default initialization based on state declarations
  }

  -- Check all system constraints
  function validate(self) -> Bool {
    for constraint in self.constraints {
      if not constraint.check(self.state) {
        return false
      }
    }
    return true
  }

  -- Get system description
  function describe(self) -> String {
    match self.exegesis {
      Some(text) { return text }
      None { return "System " + self.name }
    }
  }

  -- Check if system uses a trait
  function uses_trait<T: Trait>(self) -> Bool {
    for trait in self.traits {
      if trait.name == typename(T) {
        return true
      }
    }
    return false
  }
}

-- System state container
type SystemState is {
  fields: Map<String, Any>,
  initialized: Bool
}

-- System function entry
type SystemFunction is {
  name: String,
  signature: FunctionSignature,
  implementation: Function<...>
}

-- MLIR lowering for System
mlir System {
  type: !dol.system<{name}>

  struct state {
    -- Generated from state declarations
    fields: ...
  }

  struct vtable {
    -- Function pointers for system functions
    functions: !llvm.array<N x !llvm.ptr>
  }

  operations {
    create: dol.system.create
    get_state: dol.system.get_state
    call: dol.system.call
    validate: dol.system.validate
  }
}


-- ═══════════════════════════════════════════════════════════════════
-- EVOLVES: Version Lineage and Migration
-- ═══════════════════════════════════════════════════════════════════

gene Evolves<Current, Previous> {
  type: {
    version: Version,
    added_fields: Vec<FieldChange>,
    removed_fields: Vec<FieldChange>,
    changed_fields: Vec<FieldChange>,
    migrate_fn: Function<Previous, Current>,
    exegesis: Optional<String>
  }

  exegesis {
    Evolves tracks type evolution across versions and provides migration.
    It maintains the lineage of types as they change over time.

    This enables:
    - Safe schema evolution
    - Automatic migration between versions
    - Documentation of breaking changes
    - Rollback capabilities

    MLIR Lowering:
      evolves ProcessIdV2 > ProcessIdV1 → !dol.evolves<"ProcessIdV2", "ProcessIdV1">

    Declaration Syntax:
      evolves ProcessIdV2 > ProcessIdV1 @ 2.0.0 {
        added namespace: Optional<String>
        changed id: UInt64 -> UInt128
        removed legacy_flag

        migrate from ProcessIdV1 {
          return ProcessIdV2 {
            id: old.id as UInt128,
            namespace: None
          }
        }

        exegesis {
          V2 expands IDs to 128-bit and adds namespacing.
        }
      }

    Example:
      -- Version 1
      gene UserV1 {
        type: {
          name: String,
          email: String
        }
      }

      -- Version 2 (adds phone, renames email)
      evolves UserV2 > UserV1 @ 2.0.0 {
        added phone: Optional<String>
        changed email -> contact_email: String

        migrate from UserV1 {
          return UserV2 {
            name: old.name,
            contact_email: old.email,
            phone: None
          }
        }
      }
  }

  -- Migrate from previous version
  function migrate(old: Previous) -> Current {
    return self.migrate_fn(old)
  }

  -- Get version info
  function get_version(self) -> Version {
    return self.version
  }

  -- Get list of changes
  function get_changes(self) -> EvolutionChanges {
    return EvolutionChanges {
      added: self.added_fields.as_slice(),
      removed: self.removed_fields.as_slice(),
      changed: self.changed_fields.as_slice()
    }
  }

  -- Check if migration is needed
  function needs_migration<T>(value: T) -> Bool {
    version: Version = ?T.version
    return version < self.version
  }
}

-- Version identifier
type Version is {
  major: UInt32,
  minor: UInt32,
  patch: UInt32
}

-- Field change record
type FieldChange is {
  name: String,
  old_type: Optional<TypeInfo>,
  new_type: Optional<TypeInfo>,
  change_type: ChangeType
}

-- Type of change
type ChangeType is enum {
  Added,
  Removed,
  TypeChanged,
  Renamed(new_name: String)
}

-- Summary of evolution changes
type EvolutionChanges is {
  added: Slice<FieldChange>,
  removed: Slice<FieldChange>,
  changed: Slice<FieldChange>
}

-- MLIR lowering for Evolves
mlir Evolves<Current, Previous> {
  type: !dol.evolves<{Current.name}, {Previous.name}>

  attributes {
    version = version attr
    changes = array of change attrs
  }

  operations {
    migrate: dol.evolves.migrate
    check_version: dol.evolves.check_version
  }
}


-- ═══════════════════════════════════════════════════════════════════
-- SUPPORTING TYPES
-- ═══════════════════════════════════════════════════════════════════

-- Timestamp for metadata
type Timestamp is Int64

-- Source location for debugging
type SourceSpan is {
  file: String,
  start_line: UInt32,
  start_col: UInt32,
  end_line: UInt32,
  end_col: UInt32
}

-- Function signature for reflection
type FunctionSignature is {
  name: String,
  params: Vec<Tuple<String, TypeInfo>>,
  return_type: TypeInfo
}

-- Type information for reflection
type TypeInfo is {
  name: String,
  size: UInt64,
  alignment: UInt64,
  kind: TypeKind
}

-- Kind of type
type TypeKind is enum {
  Primitive,
  Composite,
  Gene,
  Trait,
  System,
  Function
}

-- Validation error
type ValidationError is enum {
  ConstraintViolation(violations: Vec<String>),
  TypeMismatch(expected: String, found: String),
  MissingField(name: String)
}


-- ═══════════════════════════════════════════════════════════════════
-- EXPORTS
-- ═══════════════════════════════════════════════════════════════════

export {
  -- Core ontological types
  Gene,
  Trait,
  Constraint,
  System,
  Evolves,

  -- Supporting types
  GeneMetadata,
  TraitRequirement,
  TraitProvision,
  SystemState,
  SystemFunction,
  Version,
  FieldChange,
  ChangeType,
  EvolutionChanges,

  -- Reflection types
  TypeInfo,
  TypeKind,
  FunctionSignature,
  SourceSpan,
  Timestamp,

  -- Errors
  ValidationError
}
