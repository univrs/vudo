-- DOL 2.0 Composite Types Specification
-- Part of VUDO Genesis Year 1 - Type System Design
-- Generated by Hive Mind Queen Coordinator

module dol.types.composites @ 2.0.0

exegesis {
  Composite types are types constructed from other types.
  They provide the building blocks for complex data structures
  while maintaining MLIR lowering compatibility.

  All composite types are parameterized (generic) and support
  type inference in most contexts.
}

-- ═══════════════════════════════════════════════════════════════════
-- ARRAY TYPE: Fixed-size, contiguous, stack-allocated collection
-- ═══════════════════════════════════════════════════════════════════

gene Array<T, N: UInt64> {
  type: {
    data: Pointer<T>,
    _phantom: PhantomData<(T, N)>
  }

  constraint valid_size {
    N > 0 and N <= 2^32
  }

  exegesis {
    Array<T, N> is a fixed-size collection of N elements of type T.
    Arrays are stack-allocated when size is known at compile time.

    MLIR Lowering:
      Array<Int32, 10> → !llvm.array<10 x i32>
      Array<Float64, 3> → !llvm.array<3 x f64>

    Memory Layout:
      - Elements are contiguous in memory
      - Size: sizeof(T) * N
      - Alignment: alignof(T)

    Literal Syntax:
      [1, 2, 3]: Array<Int32, 3>
      [0; 10]: Array<Int32, 10>  -- 10 zeros

    Example:
      point: Array<Float64, 3> = [1.0, 2.0, 3.0]
      matrix: Array<Array<Float64, 3>, 3> = [[1,0,0], [0,1,0], [0,0,1]]
  }

  -- Index access
  function get(self, index: UInt64) -> T {
    if index >= N {
      panic("Array index out of bounds")
    }
    return unsafe { *self.data.offset(index) }
  }

  -- Bounds-checked index access
  function try_get(self, index: UInt64) -> Optional<T> {
    if index >= N {
      return None
    }
    return Some(unsafe { *self.data.offset(index) })
  }

  -- Length is compile-time constant
  function length(self) -> UInt64 {
    return N
  }

  -- Convert to slice
  function as_slice(self) -> Slice<T> {
    return Slice { ptr: self.data, length: N }
  }
}

-- MLIR lowering for Array
mlir Array<T, N> {
  type: !llvm.array<{N} x {T.mlir}>

  operations {
    get: llvm.extractvalue
    set: llvm.insertvalue
    ptr: llvm.getelementptr
  }
}


-- ═══════════════════════════════════════════════════════════════════
-- SLICE TYPE: Dynamically-sized view into contiguous memory
-- ═══════════════════════════════════════════════════════════════════

gene Slice<T> {
  type: {
    ptr: Pointer<T>,
    length: UInt64
  }

  constraint valid_slice {
    this.ptr != null implies this.length >= 0
  }

  exegesis {
    Slice<T> is a fat pointer: pointer + length.
    Slices do not own their data; they borrow it.

    MLIR Lowering:
      Slice<Int32> → !dol.slice<!i32> = { !llvm.ptr, i64 }

    Memory Layout:
      - 16 bytes on 64-bit: 8 (ptr) + 8 (length)
      - Alignment: 8 bytes

    Literal Syntax:
      array[1..3]: Slice<Int32>  -- subslice
      &array: Slice<Int32>       -- whole array as slice

    Example:
      data: Slice<Int32> = &[1, 2, 3, 4, 5]
      sub: Slice<Int32> = data[1..4]  -- [2, 3, 4]
  }

  function get(self, index: UInt64) -> T {
    if index >= self.length {
      panic("Slice index out of bounds")
    }
    return unsafe { *self.ptr.offset(index) }
  }

  function try_get(self, index: UInt64) -> Optional<T> {
    if index >= self.length {
      return None
    }
    return Some(unsafe { *self.ptr.offset(index) })
  }

  function len(self) -> UInt64 {
    return self.length
  }

  function is_empty(self) -> Bool {
    return self.length == 0
  }

  function subslice(self, start: UInt64, end: UInt64) -> Slice<T> {
    if start > end or end > self.length {
      panic("Invalid subslice range")
    }
    return Slice {
      ptr: self.ptr.offset(start),
      length: end - start
    }
  }
}

-- MLIR lowering for Slice
mlir Slice<T> {
  type: !dol.slice<{T.mlir}>

  struct {
    ptr: !llvm.ptr
    length: i64
  }

  operations {
    create: dol.slice.create
    get: dol.slice.get
    subslice: dol.slice.subslice
  }
}


-- ═══════════════════════════════════════════════════════════════════
-- POINTER TYPE: Raw memory address (unsafe)
-- ═══════════════════════════════════════════════════════════════════

gene Pointer<T> {
  type: UInt64  -- Raw address

  exegesis {
    Pointer<T> is a raw memory address pointing to a value of type T.
    Pointer operations are inherently unsafe and require explicit marking.

    MLIR Lowering:
      Pointer<Int32> → !llvm.ptr

    Memory Layout:
      - 8 bytes on 64-bit systems
      - Alignment: 8 bytes

    Literal Syntax:
      null: Pointer<T>  -- null pointer
      &value: Pointer<T>  -- address-of

    Example:
      ptr: Pointer<Int32> = unsafe { &value }
      val: Int32 = unsafe { *ptr }
  }

  function is_null(self) -> Bool {
    return self.value == 0
  }

  function offset(self, n: Int64) -> Pointer<T> {
    return Pointer { value: self.value + n * sizeof(T) }
  }

  -- Unsafe operations require unsafe block
  unsafe function deref(self) -> T {
    return *self
  }

  unsafe function write(self, value: T) -> Void {
    *self = value
  }
}

-- MLIR lowering for Pointer
mlir Pointer<T> {
  type: !llvm.ptr

  operations {
    load: llvm.load
    store: llvm.store
    offset: llvm.getelementptr
    null_check: llvm.icmp eq, null
  }
}


-- ═══════════════════════════════════════════════════════════════════
-- OPTIONAL TYPE: Value that may or may not exist
-- ═══════════════════════════════════════════════════════════════════

gene Optional<T> {
  type: enum {
    Some(value: T),
    None
  }

  exegesis {
    Optional<T> represents a value that may be absent.
    This is DOL's null-safety mechanism - no null pointers.

    MLIR Lowering:
      Optional<Int32> → !dol.optional<!i32>
      Represented as tagged union: { i1, T }

    Memory Layout:
      - 1 byte tag + sizeof(T) + padding
      - Alignment: max(1, alignof(T))

    Literal Syntax:
      Some(42): Optional<Int32>
      None: Optional<T>

    Example:
      result: Optional<Int32> = find_value(key)
      match result {
        Some(v) { print(v) }
        None { print("not found") }
      }
  }

  function is_some(self) -> Bool {
    match self {
      Some(_) { return true }
      None { return false }
    }
  }

  function is_none(self) -> Bool {
    return not self.is_some()
  }

  function unwrap(self) -> T {
    match self {
      Some(v) { return v }
      None { panic("unwrap called on None") }
    }
  }

  function unwrap_or(self, default: T) -> T {
    match self {
      Some(v) { return v }
      None { return default }
    }
  }

  function map<U>(self, f: Function<T, U>) -> Optional<U> {
    match self {
      Some(v) { return Some(f(v)) }
      None { return None }
    }
  }

  function and_then<U>(self, f: Function<T, Optional<U>>) -> Optional<U> {
    match self {
      Some(v) { return f(v) }
      None { return None }
    }
  }
}

-- MLIR lowering for Optional
mlir Optional<T> {
  type: !dol.optional<{T.mlir}>

  struct {
    has_value: i1
    value: {T.mlir}
  }

  operations {
    some: dol.optional.some
    none: dol.optional.none
    is_some: dol.optional.is_some
    unwrap: dol.optional.unwrap
  }
}


-- ═══════════════════════════════════════════════════════════════════
-- RESULT TYPE: Success or error value
-- ═══════════════════════════════════════════════════════════════════

gene Result<T, E> {
  type: enum {
    Ok(value: T),
    Err(error: E)
  }

  exegesis {
    Result<T, E> represents either success (Ok) or failure (Err).
    This is DOL's primary error handling mechanism.

    MLIR Lowering:
      Result<Int32, String> → !dol.result<!i32, !dol.string>
      Represented as tagged union: { i1, max(T, E) }

    Memory Layout:
      - 1 byte tag + max(sizeof(T), sizeof(E)) + padding
      - Alignment: max(alignof(T), alignof(E))

    Literal Syntax:
      Ok(42): Result<Int32, String>
      Err("failed"): Result<Int32, String>

    Example:
      result: Result<Int32, IoError> = read_file(path)
      value: Int32 = try result  -- propagates error
  }

  function is_ok(self) -> Bool {
    match self {
      Ok(_) { return true }
      Err(_) { return false }
    }
  }

  function is_err(self) -> Bool {
    return not self.is_ok()
  }

  function unwrap(self) -> T {
    match self {
      Ok(v) { return v }
      Err(e) { panic("unwrap called on Err: " + e.to_string()) }
    }
  }

  function unwrap_err(self) -> E {
    match self {
      Ok(_) { panic("unwrap_err called on Ok") }
      Err(e) { return e }
    }
  }

  function map<U>(self, f: Function<T, U>) -> Result<U, E> {
    match self {
      Ok(v) { return Ok(f(v)) }
      Err(e) { return Err(e) }
    }
  }

  function map_err<F>(self, f: Function<E, F>) -> Result<T, F> {
    match self {
      Ok(v) { return Ok(v) }
      Err(e) { return Err(f(e)) }
    }
  }

  function and_then<U>(self, f: Function<T, Result<U, E>>) -> Result<U, E> {
    match self {
      Ok(v) { return f(v) }
      Err(e) { return Err(e) }
    }
  }
}

-- MLIR lowering for Result
mlir Result<T, E> {
  type: !dol.result<{T.mlir}, {E.mlir}>

  struct {
    is_ok: i1
    payload: !llvm.array<{max(sizeof(T), sizeof(E))} x i8>
  }

  operations {
    ok: dol.result.ok
    err: dol.result.err
    is_ok: dol.result.is_ok
    unwrap: dol.result.unwrap
    try: dol.result.try  -- early return on error
  }
}


-- ═══════════════════════════════════════════════════════════════════
-- TUPLE TYPE: Heterogeneous fixed-size collection
-- ═══════════════════════════════════════════════════════════════════

gene Tuple<...T> {
  type: {
    elements: T...
  }

  exegesis {
    Tuple<T...> is a heterogeneous collection of values.
    Tuples are structural types - identity by structure, not name.

    MLIR Lowering:
      Tuple<Int32, String, Bool> → !llvm.struct<(i32, !dol.string, i1)>

    Memory Layout:
      - Sum of element sizes with alignment padding
      - Alignment: max of all element alignments

    Literal Syntax:
      (1, "hello", true): Tuple<Int32, String, Bool>
      (): Tuple<>  -- unit tuple (same as Void)

    Example:
      point: Tuple<Float64, Float64> = (3.0, 4.0)
      (x, y) = point  -- destructuring
  }

  -- Compile-time indexed access
  function get<N: UInt64>(self) -> T[N] {
    return self.elements[N]
  }

  -- Arity (number of elements)
  function arity(self) -> UInt64 {
    return len(T...)
  }
}

-- MLIR lowering for Tuple
mlir Tuple<...T> {
  type: !llvm.struct<({T[0].mlir}, {T[1].mlir}, ...)>

  operations {
    create: llvm.mlir.undef + llvm.insertvalue...
    get: llvm.extractvalue
    destructure: multiple llvm.extractvalue
  }
}


-- ═══════════════════════════════════════════════════════════════════
-- FUNCTION TYPE: First-class callable
-- ═══════════════════════════════════════════════════════════════════

gene Function<Args, Ret> {
  type: {
    ptr: Pointer<Void>,      -- Function pointer
    env: Optional<Pointer<Void>>  -- Closure environment (None for bare functions)
  }

  exegesis {
    Function<Args, Ret> represents a callable with arguments Args returning Ret.
    Functions may be bare (no captures) or closures (with environment).

    MLIR Lowering:
      Function<(Int32, Int32), Int32> → !llvm.func<i32 (i32, i32)>
      Closures: { !llvm.ptr (fn), !llvm.ptr (env) }

    Memory Layout:
      - Bare function: 8 bytes (pointer)
      - Closure: 16 bytes (fn pointer + env pointer)

    Literal Syntax:
      |x: Int32| -> Int32 { x * 2 }  -- lambda
      add  -- function reference

    Example:
      double: Function<Int32, Int32> = |x| { x * 2 }
      result: Int32 = double(21)  -- 42
  }

  function call(self, args: Args) -> Ret {
    match self.env {
      Some(env) {
        return unsafe { self.ptr.call_with_env(env, args) }
      }
      None {
        return unsafe { self.ptr.call(args) }
      }
    }
  }

  function is_closure(self) -> Bool {
    return self.env.is_some()
  }
}

-- MLIR lowering for Function
mlir Function<Args, Ret> {
  type: !dol.function<({Args.mlir...}) -> {Ret.mlir}>

  struct {
    fn_ptr: !llvm.ptr
    env_ptr: !llvm.ptr  -- null for non-closures
  }

  operations {
    call: llvm.call (bare) or dol.closure.call (closure)
    create_closure: dol.closure.create
  }
}


-- ═══════════════════════════════════════════════════════════════════
-- VEC TYPE: Dynamic growable array (heap allocated)
-- ═══════════════════════════════════════════════════════════════════

gene Vec<T> {
  type: {
    ptr: Pointer<T>,
    length: UInt64,
    capacity: UInt64
  }

  constraint valid_vec {
    this.length <= this.capacity
  }

  exegesis {
    Vec<T> is a growable, heap-allocated array.
    Vectors own their data and manage memory automatically.

    MLIR Lowering:
      Vec<Int32> → !dol.vec<!i32>
      Struct: { !llvm.ptr, i64, i64 }

    Memory Layout:
      - Header: 24 bytes (ptr + length + capacity)
      - Data: capacity * sizeof(T) on heap

    Literal Syntax:
      Vec.new(): Vec<Int32>
      Vec.from([1, 2, 3]): Vec<Int32>

    Example:
      items: Vec<Int32> = Vec.new()
      items.push(1)
      items.push(2)
      items.push(3)
  }

  function new() -> Vec<T> {
    return Vec { ptr: null, length: 0, capacity: 0 }
  }

  function with_capacity(cap: UInt64) -> Vec<T> {
    return Vec {
      ptr: alloc(cap * sizeof(T)),
      length: 0,
      capacity: cap
    }
  }

  function push(self, value: T) -> Void {
    if self.length == self.capacity {
      self.grow()
    }
    unsafe { *self.ptr.offset(self.length) = value }
    self.length = self.length + 1
  }

  function pop(self) -> Optional<T> {
    if self.length == 0 {
      return None
    }
    self.length = self.length - 1
    return Some(unsafe { *self.ptr.offset(self.length) })
  }

  function len(self) -> UInt64 {
    return self.length
  }

  function is_empty(self) -> Bool {
    return self.length == 0
  }

  function as_slice(self) -> Slice<T> {
    return Slice { ptr: self.ptr, length: self.length }
  }

  private function grow(self) -> Void {
    new_cap: UInt64 = if self.capacity == 0 { 4 } else { self.capacity * 2 }
    new_ptr: Pointer<T> = realloc(self.ptr, new_cap * sizeof(T))
    self.ptr = new_ptr
    self.capacity = new_cap
  }
}

-- MLIR lowering for Vec
mlir Vec<T> {
  type: !dol.vec<{T.mlir}>

  struct {
    ptr: !llvm.ptr
    length: i64
    capacity: i64
  }

  operations {
    new: dol.vec.new
    push: dol.vec.push
    pop: dol.vec.pop
    grow: dol.vec.grow
  }
}


-- ═══════════════════════════════════════════════════════════════════
-- MAP TYPE: Key-value dictionary
-- ═══════════════════════════════════════════════════════════════════

gene Map<K, V> where K: Hashable + Eq {
  type: {
    buckets: Vec<Vec<Tuple<K, V>>>,
    length: UInt64
  }

  exegesis {
    Map<K, V> is a hash-based key-value dictionary.
    Keys must implement Hashable and Eq traits.

    MLIR Lowering:
      Map<String, Int32> → !dol.map<!dol.string, !i32>

    Example:
      ages: Map<String, Int32> = Map.new()
      ages.insert("Alice", 30)
      ages.insert("Bob", 25)
      age: Optional<Int32> = ages.get("Alice")
  }

  function new() -> Map<K, V> {
    return Map {
      buckets: Vec.with_capacity(16),
      length: 0
    }
  }

  function insert(self, key: K, value: V) -> Optional<V> {
    hash: UInt64 = key.hash()
    idx: UInt64 = hash % self.buckets.capacity
    -- Implementation details...
  }

  function get(self, key: K) -> Optional<V> {
    hash: UInt64 = key.hash()
    idx: UInt64 = hash % self.buckets.capacity
    -- Implementation details...
  }

  function remove(self, key: K) -> Optional<V> {
    -- Implementation details...
  }

  function len(self) -> UInt64 {
    return self.length
  }
}


-- ═══════════════════════════════════════════════════════════════════
-- EXPORTS
-- ═══════════════════════════════════════════════════════════════════

export {
  Array,
  Slice,
  Pointer,
  Optional, Some, None,
  Result, Ok, Err,
  Tuple,
  Function,
  Vec,
  Map
}
