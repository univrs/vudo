// Spirit Manifest Gene
// Path: docs/ontology/prospective/spirits/genes/manifest.dol
// Version: 0.1.0

module vudo.spirit @ 0.1.0

use vudo.vm.capability.CapabilityType

// ═══════════════════════════════════════════════════════════════════════════
// VERSION
// ═══════════════════════════════════════════════════════════════════════════

gene Version {
    has major: UInt32
    has minor: UInt32
    has patch: UInt32
    has prerelease: Option<String>
    has build: Option<String>
    
    constraint valid_prerelease {
        match this.prerelease {
            Some(pre) { pre.matches("[0-9A-Za-z-]+") }
            None { true }
        }
    }
    
    fun to_string() -> String {
        base = "{}.{}.{}".format(this.major, this.minor, this.patch)
        match this.prerelease {
            Some(pre) { base = base + "-" + pre }
            None { }
        }
        match this.build {
            Some(b) { base = base + "+" + b }
            None { }
        }
        return base
    }
    
    exegesis {
        Semantic versioning for Spirits.
        
        - major: Breaking changes
        - minor: New features, backward compatible
        - patch: Bug fixes only
        - prerelease: alpha, beta, rc.1, etc.
        - build: Build metadata
        
        Follows semver 2.0 specification.
    }
}

gene VersionConstraint {
    has operator: VersionOp
    has version: Version
    
    type VersionOp is enum {
        Exact,      // = 1.2.3
        GreaterEq,  // >= 1.2.3
        Greater,    // > 1.2.3
        LessEq,     // <= 1.2.3
        Less,       // < 1.2.3
        Caret,      // ^1.2.3 (compatible with)
        Tilde       // ~1.2.3 (patch-level only)
    }
    
    fun satisfies(v: Version) -> Bool {
        match this.operator {
            Exact { v == this.version }
            GreaterEq { v >= this.version }
            Greater { v > this.version }
            LessEq { v <= this.version }
            Less { v < this.version }
            Caret { v.major == this.version.major && v >= this.version }
            Tilde { v.major == this.version.major && 
                    v.minor == this.version.minor && 
                    v >= this.version }
        }
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// DEPENDENCY
// ═══════════════════════════════════════════════════════════════════════════

gene Dependency {
    has spirit_name: String
    has version_constraint: VersionConstraint
    has optional: Bool
    has features: List<String>
    
    constraint valid_name {
        this.spirit_name.matches("[a-z][a-z0-9_-]*(/[a-z][a-z0-9_-]*)?")
    }
    
    exegesis {
        Dependencies declare which other Spirits are required.
        
        Format: "author/name" or just "name" for stdlib.
        
        Features enable optional functionality:
        - Spirit can expose features
        - Dependencies can request features
        - Only compiled features are included
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// PRICING
// ═══════════════════════════════════════════════════════════════════════════

gene Pricing {
    has tier: PricingTier
    has summon_cost: UInt64
    has execution_rate: Float64
    has storage_rate: Float64
    
    type PricingTier is enum {
        Free,       // No cost
        Basic,      // Low cost, limited features
        Standard,   // Normal pricing
        Premium,    // Higher price, priority execution
        Custom      // Creator-defined pricing
    }
    
    constraint valid_rates {
        this.execution_rate >= 0.0
        this.storage_rate >= 0.0
    }
    
    exegesis {
        Pricing defines the Mycelial Credit costs for a Spirit.
        
        - summon_cost: One-time cost to summon Spirit
        - execution_rate: Credits per million fuel units
        - storage_rate: Credits per GB-hour
        
        Free tier Spirits help onboard new users.
        Creators set their own pricing to earn credits.
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// MANIFEST
// ═══════════════════════════════════════════════════════════════════════════

gene Manifest {
    has name: String
    has version: Version
    has author: PublicKey
    has description: String
    has license: String
    has homepage: Option<String>
    has repository: Option<String>
    
    has entry_point: String
    has exports: List<ExportedFunction>
    has dependencies: List<Dependency>
    has capabilities_required: List<CapabilityType>
    has features: List<Feature>
    
    has pricing: Pricing
    has categories: List<String>
    has keywords: List<String>
    
    has wasm_hash: Hash
    has signature: Signature
    has published_at: Timestamp
    
    constraint valid_name {
        this.name.length >= 3
        this.name.length <= 64
        this.name.matches("[a-z][a-z0-9_-]*")
    }
    
    constraint valid_description {
        this.description.length > 0
        this.description.length <= 500
    }
    
    constraint valid_signature {
        verify(this.author, this.signature, this.signing_payload())
    }
    
    constraint valid_entry {
        this.exports.any(|e| e.name == this.entry_point)
    }
    
    fun signing_payload() -> Bytes {
        // Hash of all fields except signature
        hash(this.name, this.version, this.author, this.wasm_hash)
    }
    
    exegesis {
        The Spirit Manifest is the complete package definition.
        
        A .spirit file contains:
        1. This manifest (manifest.toml)
        2. Compiled WASM (spirit.wasm)
        3. Source DOL (optional, src/*.dol)
        4. Documentation (optional, docs/*)
        5. Assets (optional, assets/*)
        
        The manifest is cryptographically signed by the author.
        The wasm_hash ensures binary integrity.
        
        Publishing:
        1. Author creates manifest.toml
        2. Author compiles DOL → WASM
        3. Author signs with Ed25519 key
        4. Package uploaded to Mycelium registry
        5. Other nodes verify signature + hash
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// EXPORTED FUNCTION
// ═══════════════════════════════════════════════════════════════════════════

gene ExportedFunction {
    has name: String
    has parameters: List<ParameterDef>
    has return_type: Option<TypeDef>
    has description: String
    has capabilities: List<CapabilityType>
    
    constraint valid_name {
        this.name.matches("[a-z_][a-z0-9_]*")
    }
    
    exegesis {
        ExportedFunction describes a callable entry point.
        
        Each export declares:
        - Its signature (params + return)
        - What capabilities it needs
        - Human-readable description
        
        Only exported functions can be invoked externally.
    }
}

gene ParameterDef {
    has name: String
    has type_def: TypeDef
    has optional: Bool
    has default_value: Option<Bytes>
}

gene TypeDef {
    has kind: TypeKind
    has inner: Option<TypeDef>
    has fields: List<FieldDef>
    
    type TypeKind is enum {
        Void, Bool, Int8, Int16, Int32, Int64,
        UInt8, UInt16, UInt32, UInt64,
        Float32, Float64, String, Bytes,
        List, Map, Option, Result,
        Struct, Enum
    }
}

gene FieldDef {
    has name: String
    has type_def: TypeDef
}

// ═══════════════════════════════════════════════════════════════════════════
// FEATURE
// ═══════════════════════════════════════════════════════════════════════════

gene Feature {
    has name: String
    has description: String
    has default: Bool
    has additional_capabilities: List<CapabilityType>
    has additional_dependencies: List<Dependency>
    
    constraint valid_name {
        this.name.matches("[a-z][a-z0-9_-]*")
    }
    
    exegesis {
        Features are optional Spirit functionality.
        
        Example: A "visualization" feature might:
        - Require additional graphics capabilities
        - Include extra dependencies
        - Enable 3D rendering exports
        
        Consumers choose which features to enable.
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// LINEAGE (Evolution tracking)
// ═══════════════════════════════════════════════════════════════════════════

gene Lineage {
    has ancestors: List<AncestorRef>
    has fork_reason: Option<String>
    
    exegesis {
        Lineage tracks Spirit evolution and attribution.
        
        When a Spirit forks from another:
        - Original creator gets attribution
        - Credit splits flow to ancestors
        - Evolution chain is verifiable
        
        This implements "attribution chains" from VUDO economics.
    }
}

gene AncestorRef {
    has spirit_name: String
    has version: Version
    has author: PublicKey
    has contribution: Float64
    
    constraint valid_contribution {
        this.contribution >= 0.0 && this.contribution <= 1.0
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// MANIFEST EXAMPLE
// ═══════════════════════════════════════════════════════════════════════════

/*
manifest.toml example:

[spirit]
name = "hello-world"
version = "1.0.0"
author = "univrs/hello-world"
description = "A simple Spirit that greets users"
license = "MIT"
entry_point = "greet"

[pricing]
tier = "Free"
summon_cost = 0
execution_rate = 0.0
storage_rate = 0.0

[[exports]]
name = "greet"
description = "Returns a greeting message"
capabilities = ["ActuatorLog"]

[exports.parameters]
name = { type = "String", optional = true }

[exports.return_type]
type = "String"

[[dependencies]]
name = "std/string"
version = "^1.0"

[capabilities]
required = ["SensorTime", "ActuatorLog"]
*/
