// Generated by dol-codegen from Metal DOL declarations
// Do not edit manually - regenerate from source .dol files

// Source: /home/ardeshir/repos/univrs-vudo/spirits/thermodynamic/dol/eroei.dol
// Generated by DOL compiler
// Do not edit manually

#[derive(Debug, Clone, PartialEq)]
pub struct EnergyComponent {
    pub name_id: i64,
    pub component_type: i64,
    pub energy_output_kwh_year: f64,
    pub energy_input_kwh_year: f64,
    pub embodied_energy_kwh: f64,
    pub lifespan_years: f64,
}

impl EnergyComponent {
    pub fn new(name_id: i64, component_type: i64, energy_output_kwh_year: f64, energy_input_kwh_year: f64, embodied_energy_kwh: f64, lifespan_years: f64) -> Self {
        Self {
            name_id,
            component_type,
            energy_output_kwh_year,
            energy_input_kwh_year,
            embodied_energy_kwh,
            lifespan_years,
        }
    }

    pub fn annualized_embodied(&self) -> f64 {
        return (self.embodied_energy_kwh / self.lifespan_years);
    }

    pub fn total_annual_input(&self) -> f64 {
        let mut amortized: f64 = (self.embodied_energy_kwh / self.lifespan_years);
        return (self.energy_input_kwh_year + amortized);
    }

    pub fn eroei(&self) -> f64 {
        let mut input: f64 = (self.energy_input_kwh_year + (self.embodied_energy_kwh / self.lifespan_years));
        if (input <= 0.0_f64) {
    return 999999.0_f64;
};
        return (self.energy_output_kwh_year / input);
    }
}


#[derive(Debug, Clone, PartialEq)]
pub struct EnergySystemMetrics {
    pub total_output_kwh: f64,
    pub total_input_kwh: f64,
    pub component_count: i64,
}

impl EnergySystemMetrics {
    pub fn new(total_output_kwh: f64, total_input_kwh: f64, component_count: i64) -> Self {
        Self {
            total_output_kwh,
            total_input_kwh,
            component_count,
        }
    }

    pub fn system_eroei(&self) -> f64 {
        if (self.total_input_kwh <= 0.0_f64) {
    return 0.0_f64;
};
        return (self.total_output_kwh / self.total_input_kwh);
    }

    pub fn net_energy(&self) -> f64 {
        return (self.total_output_kwh - self.total_input_kwh);
    }

    pub fn is_viable(&self) -> f64 {
        let mut eroei: f64 = (self.total_output_kwh / self.total_input_kwh);
        if (eroei >= 7.0_f64) {
    return 1.0_f64;
};
        return 0.0_f64;
    }

    pub fn viability_level(&self) -> i64 {
        let mut eroei: f64 = (self.total_output_kwh / self.total_input_kwh);
        if (eroei >= 20.0_f64) {
    return 5_i64;
};
        if (eroei >= 12.0_f64) {
    return 4_i64;
};
        if (eroei >= 7.0_f64) {
    return 3_i64;
};
        if (eroei >= 5.0_f64) {
    return 2_i64;
};
        if (eroei >= 3.0_f64) {
    return 1_i64;
};
        return 0_i64;
    }

    pub fn viability_assessment(&self) -> i64 {
        let mut eroei: f64 = (self.total_output_kwh / self.total_input_kwh);
        if (eroei >= 20.0_f64) {
    return 5_i64;
};
        if (eroei >= 12.0_f64) {
    return 4_i64;
};
        if (eroei >= 7.0_f64) {
    return 3_i64;
};
        if (eroei >= 5.0_f64) {
    return 2_i64;
};
        if (eroei >= 3.0_f64) {
    return 1_i64;
};
        return 0_i64;
    }
}


pub fn create_solar_pv_component() -> f64 {
    let mut output: f64 = 1500000.0_f64;
    let mut operational: f64 = 10000.0_f64;
    let mut annualized_embodied: f64 = 60000.0_f64;
    let mut total_input: f64 = (operational + annualized_embodied);
    return (output / total_input);
}


pub fn hyphal_node_energy(num_nodes: i64, power_per_node_w: f64) -> f64 {
    let mut hours_per_year: f64 = 8760.0_f64;
    let mut node_count: f64 = num_nodes as f64;
    return (node_count * (power_per_node_w * (hours_per_year / 1000.0_f64)));
}


pub fn max_supported_nodes(solar_mw: f64, node_power_w: f64) -> i64 {
    let mut capacity_factor: f64 = 0.17_f64;
    let mut distribution_efficiency: f64 = 0.8_f64;
    let mut hours_per_year: f64 = 8760.0_f64;
    let mut annual_kwh: f64 = (solar_mw * (1000.0_f64 * (capacity_factor * hours_per_year)));
    let mut usable_kwh: f64 = (annual_kwh * distribution_efficiency);
    let mut per_node_kwh: f64 = (node_power_w * (hours_per_year / 1000.0_f64));
    return (usable_kwh / per_node_kwh) as i64;
}


pub fn create_solar_pv_eroei() -> f64 {
    let mut output: f64 = 1500000.0_f64;
    let mut operational: f64 = 10000.0_f64;
    let mut annualized_embodied: f64 = 60000.0_f64;
    let mut total_input: f64 = (operational + annualized_embodied);
    return (output / total_input);
}


pub fn solar_system_example() -> EnergySystemMetrics {
    let mut output: f64 = 1489200.0_f64;
    let mut input: f64 = 70000.0_f64;
    return EnergySystemMetrics::new(output, input, 1_i64);
}


pub fn hyphal_network_example(num_nodes: i64) -> EnergySystemMetrics {
    let mut per_node_kwh: f64 = 87.6_f64;
    let mut node_count: f64 = num_nodes as f64;
    let mut total_input: f64 = (node_count * per_node_kwh);
    return EnergySystemMetrics::new(0.0_f64, total_input, num_nodes);
}




// Source: /home/ardeshir/repos/univrs-vudo/spirits/thermodynamic/dol/small_world.dol
// Generated by DOL compiler
// Do not edit manually

#[derive(Debug, Clone, PartialEq)]
pub struct Edge {
    pub from_node: i64,
    pub to_node: i64,
}

impl Edge {
    pub fn new(from_node: i64, to_node: i64) -> Self {
        Self {
            from_node,
            to_node,
        }
    }
}


#[derive(Debug, Clone, PartialEq)]
pub struct GraphMetrics {
    pub node_count: i64,
    pub edge_count: i64,
    pub clustering: f64,
    pub path_length: f64,
}

impl GraphMetrics {
    pub fn new(node_count: i64, edge_count: i64, clustering: f64, path_length: f64) -> Self {
        Self {
            node_count,
            edge_count,
            clustering,
            path_length,
        }
    }

    pub fn average_degree(&self) -> f64 {
        let mut n: f64 = self.node_count as f64;
        let mut m: f64 = self.edge_count as f64;
        return (2.0_f64 * (m / n));
    }
}


#[derive(Debug, Clone, PartialEq)]
pub struct SmallWorldMetrics {
    pub n: i64,
    pub m: i64,
    pub k: f64,
    pub clustering: f64,
    pub path_length: f64,
    pub c_random: f64,
    pub l_random: f64,
}

impl SmallWorldMetrics {
    pub fn new(n: i64, m: i64, k: f64, clustering: f64, path_length: f64, c_random: f64, l_random: f64) -> Self {
        Self {
            n,
            m,
            k,
            clustering,
            path_length,
            c_random,
            l_random,
        }
    }

    pub fn gamma(&self) -> f64 {
        if (self.c_random <= 0.0_f64) {
    return 0.0_f64;
};
        return (self.clustering / self.c_random);
    }

    pub fn lambda(&self) -> f64 {
        if (self.l_random <= 0.0_f64) {
    return 0.0_f64;
};
        return (self.path_length / self.l_random);
    }

    pub fn sigma(&self) -> f64 {
        let mut g: f64 = (self.clustering / self.c_random);
        let mut l: f64 = (self.path_length / self.l_random);
        if (l <= 0.0_f64) {
    return 0.0_f64;
};
        return (g / l);
    }

    pub fn is_small_world(&self) -> f64 {
        let mut g: f64 = (self.clustering / self.c_random);
        let mut l: f64 = (self.path_length / self.l_random);
        let mut s: f64 = (g / l);
        if (s > 1.0_f64) {
    return 1.0_f64;
};
        return 0.0_f64;
    }

    pub fn interpretation(&self) -> i64 {
        let mut g: f64 = (self.clustering / self.c_random);
        let mut l: f64 = (self.path_length / self.l_random);
        let mut s: f64 = (g / l);
        if (s > 3.0_f64) {
    return 3_i64;
};
        if (s > 1.5_f64) {
    return 2_i64;
};
        if (s > 1.0_f64) {
    return 1_i64;
};
        return 0_i64;
    }
}


pub fn random_clustering(n: i64, k: f64) -> f64 {
    let mut node_count: f64 = n as f64;
    return (k / node_count);
}


pub fn random_path_length_approx(n: i64, k: f64) -> f64 {
    let mut node_count: f64 = n as f64;
    return (node_count / k);
}


pub fn calculate_sigma(c: f64, l: f64, c_random: f64, l_random: f64) -> f64 {
    if (c_random <= 0.0_f64) {
    return 0.0_f64;
};
    if (l_random <= 0.0_f64) {
    return 0.0_f64;
};
    let mut gamma: f64 = (c / c_random);
    let mut lambda: f64 = (l / l_random);
    if (lambda <= 0.0_f64) {
    return 0.0_f64;
};
    return (gamma / lambda);
}


pub fn is_small_world_network(sigma: f64, min_clustering: f64, c: f64) -> f64 {
    if (sigma > 1.0_f64) {
    if (c >= min_clustering) {
    return 1.0_f64;
};
};
    return 0.0_f64;
}


pub fn random_path_length(n: i64, k: f64) -> f64 {
    let mut node_count: f64 = n as f64;
    return (node_count / k);
}


pub fn dunbar_cluster_example() -> SmallWorldMetrics {
    let mut n: i64 = 150_i64;
    let mut m: i64 = 450_i64;
    let mut k: f64 = 6.0_f64;
    let mut clustering: f64 = 0.5_f64;
    let mut path_length: f64 = 2.5_f64;
    let mut c_random: f64 = (k / 150.0_f64);
    let mut l_random: f64 = (150.0_f64 / k);
    return SmallWorldMetrics::new(n, m, k, clustering, path_length, c_random, l_random);
}





// WASM bindings (hand-written wrapper for wasm-bindgen)
#[cfg(target_arch = "wasm32")]
mod wasm;

#[cfg(target_arch = "wasm32")]
pub use wasm::*;

